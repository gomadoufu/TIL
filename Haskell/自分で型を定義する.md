# 自分で型を定義する

自分で型を定義する方法はいくつかある。



## 既存の方に別名をつける(type宣言)

まず既存の型に別名をつけてみる。
型に別名をつけるには、`type`を使う。
書式: `type 型の別名 = 型`

たとえば、絶対温度型KをDouble型の別名として定義すると、

```haskell
type K = Double
```

のように書ける。ソースコードにプログラマの意図をより反映させることができるようになる。



## 既存の型をベースにした新しい型を作る(newtype宣言)

次に、既存の型を拡張した型を定義してみる。
書式: `newtype 新しい型名となる型コンストラクタ = 値コンストラクタ ベースとなる既存の型`

たとえば、絶対温度型KをDouble型を元にして作ると、
```haskell
newtype K = K Double
```

と書ける。newtypeではコンストラクタは１つしかないので、型名と同じ名前にしてしまうことが多いとのこと。ちなみにコンストラクタは、その型の値を作る関数になっている。
```haskell
:t K --K :: Double -> K
```



typeと何が違うのか？
newtypeとして新しく型を定義すると、たとえば摂氏温度型newtype C = C Doubleを引数に取る関数に絶対温度型を渡した時に、ちゃんとコンパイルエラーになる。
もしKもCもDoubleの別名としてtype宣言されていたら、コンパイルエラーになってくれない。



## 完全に新しい型を作る(代数データ型・data宣言)

さて、既存の型にとらわれない新しい型を、自分で定義してみる。
新しい型を作るには、以下のような構文でdata宣言する。

```
data 新しい型名となる型コンストラクタ 型変数 = 値コンストラクタ1 既存の型か型変数 ...
                                       | 値コンストラクタ2 既存の型か型変数 ...
                                       .
                                       .
```

この宣言は、「イコールの左辺の型は、コンストラクタ1によって作られる値、またはコンストラクタ2によって作られる値、または、......を値としてもつ。」という意味。

最低限必要なのは型コンストラクタと値コンストラクタのみであり、型変数は必要なければ書かない。(実際、newtype宣言はこのタイプのdata宣言と見ることもできる)
また、既存の型すら使わないBool型のような例もある。

```haskell
data Bool = False
					 | True
```

この場合、FalseやTrueは単独でBool型の値になる。型定義も関数ではない。
```haskell
:t True --True :: Bool
```



dataで定義されるデータ型は、**代数データ型** *algebraic data type* と呼ばれる。Haskellで定義されるデータ型はすべてこの「代数データ型」となる。

代数データ型による型定義では、ある型に属する値は型定義で値コンストラクタが与えられたものしか存在しないことが保証される。
このことはコンパイラも理解しており、もしBool型の値に対して何らかの処理を記述した場合に、コンパイラは

- Trueの場合しか書いていなかったら、Falseの場合が不足していること
- TrueとFalseに加え、そのほかの場合のことが書いてあったら、それが無駄であること(プログラマのミスであること)

を指摘することができる。この性質は、パターンマッチにおいて重要になる。



### レコード構文

RGB色空間を表現した型を作ってみる。各色成分は0~1のFloat型で表すことにする。
```haskell
data RGBA = RGBA Float Float Float Float

RGBA 0.25 0.5 0.75 1 :: RGBA --コンストラクトして値を構築
```

これでもいいが、すべて同じFloatなので、どれが何色の成分なのかよくわからない。そこで、**レコード**を使った型定義をしてみる。
レコードでは、値コンストラクタの受け取る引数にフィールド名を付けることで、そのフィールド名でコンストラクトをおこなったり、値を取り出したりできるようになる。次のような構文で宣言する。

```
data 型コンストラクタ = 値コンストラクタ { フィールド1 :: 既存の型か型変数,
																			フィールド2 :: 既存の型か型変数,
																			.
																			.
																			}
```

レコードを使ってRGBA型を定義し直してみる。
```haskell
data RGBA = RGBA { getR :: Float,
									 getG :: Float,
									 getB :: Float,
									 getA :: Float,
								  }
```

こうすると、レコード名でわかりやすくコンストラクトできるほか、レコード名を使ってRGBA値から値を取り出すことができる。
```haskell
let rgba = RGBA { getA = 1, getR = 1, getG = 1, getB = 0.5 } --レコードにより順不同

getR rgba --1.0
getG rgba --1.0
getB rgba --0.5

:t getR --getR :: RGBA -> Float    各フィールド名はgetterになっている
```



### 再帰型の定義

今まで"既存の型か型変数"と書かれていたところに、定義しようとしている自分自身の型を書くことで、再帰型の定義ができる。これにより、スマートな型定義ができる場合がある。たとえば自然数型は、再帰型を用いて次のように書ける。
```haskell
data Nat = Zero | Succ Nat

:t Zero --Zero :: Nat (0相当）
:t Succ Zero --Succ Zero :: Nat (1相当)
:t Succ (Succ Zero) --Succ (Succ Zero) :: Nat (2相当）
```

### 多相型と再帰型による2分木の定義

多相型と再帰型により、リストや2分木を作ることができる。
```haskell
data Tree a = Leaf { element :: a } --末端
						| Fork { element :: a   --枝分かれ
									 , left    :: Tree a
									 , right   :: Tree a
									 }
```

この定義では、値コンストラクタLeafは末端のノードである葉を、値コンストラクタForkは枝分かれのノードを表現している。また、各ノードにはa型のフィールドelementと、左部分木および右部分木が格納されている。



### 代数データ型と直積・直和

代数データ型とは、「直積で表されたいくつかの型を直和にした型」のこと。つまり、代数データ型はタプルで表せる型をEitherで組み合わせたものと本質的には同じ。
上の2分木を例に挙げると、

```haskell
data Tree a = Leaf a
					  | Fork a (Tree a) (Tree a)
```

Fork の要素をタプルにすると
```haskell
data Tree a = Leaf a
					  | Fork (a (Tree a) (Tree a))
```

これは、Leaf a とFork (a (Tree a) (Tree a)) の Either型と見ることができる。
このように、代数データ型は本質的にはタプルとEitherであり、また、代数データ型に対する考察はタプルとEitherに対する考察に帰着するということ。





