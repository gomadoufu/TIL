# Haskellの型

その前に...

## 値

値 valueは、プログラム中で操作の対象となる、具体的な何らかのデータ。
関数型言語では、その特徴として関数自体も値になれる。関数が値になれるということは、処理もデータとして扱えるということ。



#### リテラル

リテラルとは、プログラム中での値の表現のこと。
Haskellでは

- 数値リテラル ... 0 1 42 3.14 0.01 1.0e-2
- 文字リテラル 'A'  '\\n'　(Haskellの文字は基本的にUnicode)
- 文字列リテラル"Hello, World!"
- ラムダ式(関数リテラル) ... \\x -> x*2
  (\\x -> x *2) 2 → 出力:4  半角スペースで関数適用できる

などがある。



#### 変数への束縛

束縛 binding にはletをつかう

```haskell
let one = 1
let double = \x -> 2*x
```



## 型

Haskellの型名は**アルファベット大文字開始**。TypeScriptは小文字開始だったけど。

また、型注釈はコロンふたつ :: 。TypeScriptやRustはひとつだったけど。

```haskell
let one :: Int;
one = 1 --1

let two :: Double;
two = 2 --2.0
```

GHCiで:typeまたは:tとすると、型がわかる。

```haskell
:t 1 < 2 --1 < 2 :: Bool
:t 10 + one --10 + one :: Int
```

関数にも型がつく。

```haskell
:t not --組み込みのnot関数
--not :: Bool -> Bool

:t (&&) --組み込みの論理積演算子。True && False のように用いる。関数のように(&&)True Falseとも書ける。
--(&&) :: Bool -> Bool -> Bool
```

&&について、->は右結合なので、この関数の型は Bool -> (Bool -> Bool)。この型は、Bool型の値を受け取って「Bool型の値を受け取りBool型の値を返す関数」を返す関数という意味になる。
このとき、関数&&は2引数関数ではなく、1引数関数を返す1引数関数であることに注意。

**Haskellには1より大きい「n引数関数」というものは存在しない。**
あえていうなら、n引数関数とは「1つ引数を与えられるとn-1引数関数になる」1引数関数のこと。
また、これを利用して、例えば (&&)に1つだけ真偽値を与えた別の関数を作ることもできる。

```haskell
let andT = (&&) True

:t andT
--andT :: Bool -> True

andT True --True
andT False --False
```

このように、(いわゆる)n引数関数を1引数関数で構成される形にすることを、*カリー化*という。Haskellの関数はカリー化されている。



