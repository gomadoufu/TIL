# 多相型と型変数

データ構造としてのコンテナを考える。このとき、C++であればテンプレート、Javaであればジェネリクスを使うように、コンテナの中に入れるデータの型について多相的(ポリモーフィック)に扱う方法が欲しくなる。

Haskellでは、これを**多相型** *polymorphic type* と**型変数** *type variable*で表現する。型変数の入った型を多相型という。基本的な多相型のデータ構造としては、

- リスト
- タプル
- Either
- Maybe

がある。



### リスト

リストの内容物は、単一の型以外は許されない。つまりPythonみたく型を混ぜこぜにできない。
リストは、リテラルとして [ ] と , をもつ。
また、リストの例として、以下のようなものがある。

- 多倍長整数のリスト [1, 2, 3, 4]
- 倍精度浮動小数点数のリスト [1.0, 2.7, 3.14]
- 文字のリスト ['H', 'e', 'l', 'l', 'o']



さて、リストの多相を実現するために、型変数が導入されている。型変数はよく`a`で表される。
リスト型[a]の先頭要素を得る関数として定義されている関数headの型を見ると、

```haskell
:t head --head :: [a] -> a
```

となっている。aの部分にはどのような型が入ってもいいので、関数headは「リストという型の構造は気にするけど、その中身の型は気にしない」という多相的な関数だということがわかる。

また、headの引数の型[a]は、型aを[ ]で包むことでできている。このように、ある型にくっつけて別の型を構築するもののことを**型コンストラクタ** *type constructor*と呼ぶ。[ ]はリストの型コンストラクタである。紛らわしいが、リストのリテラル表記とは意味が異なるので注意。

headの型定義には型変数はaの一つしか現れなかったが、もし同じ名前の型変数が複数箇所に現れてきたら、それらは同じ型である必要がある。リストの結合演算子 (++)の型では、3ヶ所に型変数aが現れる。これらは、厳密に同じ型でなければならない。
```haskell
:t (++) --(++) :: [a] -> [a] -> [a]
-- リストを2つ受け取り、結合したリストを返すが、それら3つのリストの型は同じでなければならない
```



### タプル

2つの値を組みにした構造をタプルと呼ぶ。タプルもまた多相型である。
タプルはリストと異なり、違う型の値で作ることができるが、要素数は2つで固定。

- (1 :: Int, 2 :: Double)
- (True, "foo")
- ('A', 1.0)

タプルの型は、ある型aとある型bにより (a, b)という多相型になる。
また、(a , b)における( , )はタプルの型コンストラクタである。

タプルに特徴的な関数として、タプルから1つ目を取り出す関数fstと、2つ目を取り出すsndが用意されている。
```haskell
:t fst --fst :: (a, b) -> a
fst (True, "foo") --True

:t snd --snd :: (a, b) -> b
snd (True, "foo") --"foo"
```



### Either

