# 多相型と型変数

データ構造としてのコンテナを考える。このとき、C++であればテンプレート、Javaであればジェネリクスを使うように、コンテナの中に入れるデータの型について多相的(ポリモーフィック)に扱う方法が欲しくなる。

Haskellでは、これを**多相型** *polymorphic type* と**型変数** *type variable*で表現する。型変数の入った型を多相型という。基本的な多相型のデータ構造としては、

- リスト
- タプル
- Maybe
- Either

がある。



### リスト

リストの内容物は、単一の型以外は許されない。つまりPythonみたく型を混ぜこぜにできない。
リストは、リテラルとして [ ] と , をもつ。
また、リストの例として、以下のようなものがある。

- 多倍長整数のリスト [1, 2, 3, 4]
- 倍精度浮動小数点数のリスト [1.0, 2.7, 3.14]
- 文字のリスト ['H', 'e', 'l', 'l', 'o']



さて、リストの多相を実現するために、型変数が導入されている。型変数はよく`a`で表される。
リスト型[a]の先頭要素を得る関数として定義されている関数headの型を見ると、

```haskell
:t head --head :: [a] -> a
```

となっている。aの部分にはどのような型が入ってもいいので、関数headは「リストという型の構造は気にするけど、その中身の型は気にしない」という多相的な関数だということがわかる。

また、headの引数の型[a]は、型aを[ ]で包むことでできている。このように、ある型にくっつけて別の型を構築するもののことを**型コンストラクタ** *type constructor*と呼ぶ。[ ]はリストの型コンストラクタである。紛らわしいが、リストのリテラル表記とは意味が異なるので注意。

headの型定義には型変数はaの一つしか現れなかったが、もし同じ名前の型変数が複数箇所に現れてきたら、それらは同じ型である必要がある。リストの結合演算子 (++)の型では、3ヶ所に型変数aが現れる。これらは、厳密に同じ型でなければならない。
```haskell
:t (++) --(++) :: [a] -> [a] -> [a]
-- リストを2つ受け取り、結合したリストを返すが、それら3つのリストの型は同じでなければならない
```



### タプル

2つの値を組みにした構造をタプルと呼ぶ。タプルもまた多相型である。
タプルはリストと異なり、違う型の値で作ることができるが、要素数は2つで固定。

- (1 :: Int, 2 :: Double)
- (True, "foo")
- ('A', 1.0)

タプルの型は、ある型aとある型bにより (a, b)という多相型になる。
また、(a , b)における( , )はタプルの型コンストラクタである。

タプルに特徴的な関数として、タプルから1つ目を取り出す関数fstと、2つ目を取り出すsndが用意されている。
```haskell
:t fst --fst :: (a, b) -> a
fst (True, "foo") --True

:t snd --snd :: (a, b) -> b
snd (True, "foo") --"foo"
```



### Maybe

Maybeは、ある型aに無効な値を加えた型Maybe aを作る。

Maybeは型を１つ包んでMaybe a型を作る型コンストラクタである。たとえばMaybe Stringという型は、有効なStringの型の値か、もしくは無効な値を持つ型ということ。

また、Maybeの有効OR無効の選択は、値コンストラクタ(データコンストラクタ、あるいは単にコンストラクタともいう)の`Just`か`Nothing`で表現する。

```haskell
Just "foo" --Just "foo"
Nothing --Nothing
```

ある処理が成功したらJust、失敗したらNothingを返すようにすることで、例外処理を書けたりするらしい。



### Either

2つの型の値のうち、どちらかを取る構造(というかモナド)をEitherと呼ぶ。2つの型のどちらかになるのでEitherもまた多相型である。

Eitherの「どちらか」の選択は、値コンストラクタの`Left`か`Right`によって表現する。
```haskell
Left 1 :: Either Int String --Left 1
Right "test" :: Either Int String --Right "test"
```

Eitherは型変数a,bによりEither a b という多相型になる。このとき、Eitherは型を２つ包んでEither a b型を作る型コンストラクタである。

Eitherをどのような時に使うのか？

> 例外処理の際、失敗した計算を扱えます。Maybeモナドでは失敗した場合`Nothing`が返るだけで詳しい情報が得られませんが、Eitherでは失敗をより詳細に表現できます。

こんな感じ:
```haskell
foo :: Int -> Either String Int --Int型を受け取ってEither型を返す関数
foo x
   | x > 5 = Right x
   | otherwise = Left "error"
   
foo 3 --Left "error"
foo 6 --Right 6
```



