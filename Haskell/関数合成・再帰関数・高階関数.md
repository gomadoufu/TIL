# 関数合成・再帰関数・高階関数

## 関数定義

関数定義は、
```
関数名 :: 文脈 => 型 -> ... -> 型
関数名 変数名 = 式
```

## 関数合成

型Xから型Yへのある関数gと、型Yから型Zへのある関数fがあったとき、このfとgを**関数合成**できる。
Haskellでは、関数合成をドット`.`で行う。

例えば、10進整数の桁数を求める関数digitsを作りたいとき、関数showとlengthを
```haskell
let digits :: Int -> Int;
ditits = length . show
```

のように関数合成する。数学と同じく、引数に近い方(この場合show)の方が先に関数適用されることに注意。

ラムダ式で表すと、関数合成`f.g`は`\x -> f (g x)`と同等。

## 再帰関数

Haskellには、for文やwhile文のようなループがない。反復的な挙動の定義には**再帰関数**を使う。

リストの長さを得る関数を再帰で定義してみる。
```haskell
length' :: [a] -> Int
length' [] = 0 --リストが空の場合
length' (x:xs) = 1 + length' xs --リストが空でない場合
```

ちなみに、以上のようにデータの構造を(最初は、、毎回、、のように)分解しながら、分解した中身の一部に対して再帰を行うことを、特に*構造再帰*と呼ぶ。

再帰関数を紹介したが、実際はlengthのように必要な機能は既に提供されている場合が多い。構造再帰を直接書くことはデータの構造にプログラミングが依存していて、低級な行為と認識されることもある。
そのために、再帰関数を直接利用せずに、高階関数をうまく利用するのが推奨される。高階関数をうまく利用すれば、データの構造を気にせずに、処理自体にまるまる変換をかけられるような関数を組み合わせて、理想的なプログラミングができる。
だいたい、自分が作る関数より、たいてい先人の作った関数の方がよくできている。

## 高階関数

関数型言語の特徴は、関数が第一級の対象であることだった。つまり、関数が関数の引数になったり、関数の結果になったりすることができる。このような、

- 引数として関数を要求する関数
- 結果が関数になる関数

を、特に**高階関数** *higher-order function*と呼ぶ。

Haskellの(便宜上)2引数以上の関数はカリー化されていて、部分適用すると結果が関数になるので、これらは全て高階関数ということになる。

引数として関数を要求する高階関数の型には、関数の型である「型 -> 型」が現れる。例えば、関数合成の2項演算子`.`の型は、
```haskell
> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

のようになっている。

---

Haskellには、色々な高階関数が用意されている。リストに対する高階関数がよく使われる。

### filter

型:
```haskell
filter :: (a -> Bool) -> [a] -> [a]
```



