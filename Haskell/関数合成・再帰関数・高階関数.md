# 関数合成・再帰関数・高階関数

## 関数定義

関数定義は、
```
関数名 :: 文脈 => 型 -> ... -> 型
関数名 変数名 = 式
```



## 関数合成

型Xから型Yへのある関数gと、型Yから型Zへのある関数fがあったとき、このfとgを**関数合成**できる。
Haskellでは、関数合成をドット`.`で行う。

例えば、10進整数の桁数を求める関数digitsを作りたいとき、関数showとlengthを
```haskell
let digits :: Int -> Int;
ditits = length . show
```

のように関数合成する。数学と同じく、引数に近い方(この場合show)の方が先に関数適用されることに注意。

ラムダ式で表すと、関数合成`f.g`は`\x -> f (g x)`と同等。



## 再帰関数

Haskellには、for文やwhile文のようなループがない。反復的な挙動の定義には**再帰関数**を使う。

リストの長さを得る関数を再帰で定義してみる。
```haskell
length' :: [a] -> Int
length' [] = 0 --リストが空の場合
length' (x:xs) = 1 + length' xs --リストが空でない場合
```

ちなみに、以上のようにデータの構造を(最初は、、毎回、、のように)分解しながら、分解した中身の一部に対して再帰を行うことを、特に**構造再帰**と呼ぶ。

再帰関数を紹介したが、実際はlengthのように必要な機能は既に提供されている場合が多い。構造再帰を直接書くことはデータの構造にプログラミングが依存していて、低級な行為と認識されることもある。
そのために、再帰関数を直接利用せずに、高階関数をうまく利用するのが推奨される。高階関数をうまく利用すれば、データの構造を気にせずに、処理自体にまるまる変換をかけられるような関数を組み合わせて、理想的なプログラミングができる。
だいたい、自分が作る関数より、たいてい先人の作った関数の方がよくできている。



## 高階関数

関数型言語の特徴は、関数が第一級の対象であることだった。つまり、関数が関数の引数になったり、関数の結果になったりすることができる。このような、

- 引数として関数を要求する関数
- 結果が関数になる関数

を、特に**高階関数** *higher-order function*と呼ぶ。

Haskellの(便宜上)2引数以上の関数はカリー化されていて、部分適用すると結果が関数になるので、これらは全て高階関数ということになる。

引数として関数を要求する高階関数の型には、関数の型である「型 -> 型」が現れる。例えば、関数合成の2項演算子`.`の型は、
```haskell
> :t (.)
(.) :: (b -> c) -> (a -> b) -> a -> c
```

のようになっている。

---

Haskellには、色々な高階関数が用意されている。リストに対する高階関数がよく使われる。

### filter

型:
```haskell
filter :: (a -> Bool) -> [a] -> [a]
```

`filter`は、リストの各要素のうち`a -> Bool`の関数の結果が真になるものだけを残す関数。

### map

型:

```haskell
map :: (a -> b) -> [a] -> [b]
```

`map`は、リストの中身を、1つ1つ`a -> b`という型の関数で変換し、`a`でできたリスト全体を`b`のリストに変換してしまう関数。

### zip

型:

```haskell
zip :: [a] -> [b] -> [(a, b)]
```

`zip`は型の見た目通り、二つのリストを引数に取り、対応する位置にある要素をタプルにしたリストを返す関数。

### zipWith

型:

```haskell
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
```

`zipWith`は`a -> b -> c`という関数と、a, bの2つのリストをとり、それらの対応する要素同士を関数で変換し、1つのリストcにまとめる関数。



### foldl/foldr

型:

```haskell
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
```

`Foldable`とは、「一つの値に**畳み込む**やり方が決められているデータ構造」を表す型クラス。リストで使われることを想定して、`Foldable t`をリストで読み替えると、例えば`foldr`の型は次のようになる。

```haskell
foldr :: (a -> b -> b) -> b -> [a] -> b
```

型の意味としては「aとbを受け取ってbを返す関数と、b型の値、a型のリストを受け取って、b型の値を返す」になる。実際の挙動としては、「与えたa型のリストの要素を**後ろから**、与えた関数でb型の値に変換しつつ、与えたb型の値に畳み込んで1つの値に変換する」動きをする。

`foldr`は後ろ(右)から優先的に畳み込み、一方`foldl`はリストの先頭(左)から優先的に畳み込む。



### scanl/scanr

型:

```haskell
scanr :: (a -> b -> b) -> b -> t a -> [b]
scanr :: (b -> a -> b) -> b -> t a -> [b]
```

`foldl/r`に似ているが、結果の値がリストになっている。`scanl/scanr`は、`foldl/foldr`の畳み込みの際の、それぞれの時点の値を並べたリストを返す。







