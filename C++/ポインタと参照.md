# ポインタと参照

シンボリックリンクだと思えばよい


int型の変数への参照を許容するポインタpを(便宜的な)ポインタ宣言子 `*` で作成し、アドレス演算子&で得た変数xのアドレスを代入する

``` C++
int x = 5;
int *p = &x;
```



どの変数も参照していないポインタは、ヌルポインタ `nullptr`で表す
``` C++
int *p = nullptr;
```

ポインタを受け取ったらNULLチェックしておきたい
``` C++
if (p == nullptr) return false;
```



ポインタが指す変数を参照する(デリファレンス)には、間接演算子 `*` を用いる

``` C++
int x = 5;
int *p = &x;
int y = *p;

// x = 5, y = 5

*p = 10;

// x = 10, y = 5
```



積極的にconstをつけていきたい

``` C++
int x = 5;

int const *p = &x 
  //ポインタpを不変にする。 p = &y などができなくなる
const int *p = &x 
  //ポインタの参照先を不変にする。 *p = 10 などができなくなる

const int const *p //併用もできる
```





ポインタに似たものとして参照がある
``` C++
int x = 100;
int *p = &x; // pはポインタ型
int &r = x; // rは参照型

*p = 200;
r = 200;
// 
```

参照は、より安全で、制約の厳しいポインタであると思うとよい。
また、無効値nullptrのようなものが存在しない。
ポインタと参照の違い↓

> オブジェクト型に限っていえば、ポインタには大きく分けて三つの用途があるかと思います。
>
> ・オブジェクトの参照
> ・反復子
> ・動的オブジェクトの管理
>
> 「ポインタ」という一種類の言語機能で、これだけのことを扱えるわけですし、しかも上記のうち複数を組み合わせることもできるわけですから、自由度が高いことは間違いありません。
> しかし、その観点からすれば、いっそ型なんかなくして、アセンブリ言語のようにしてしまえば、さらに自由度が高まりますね。
>
> 自由度を落として制限を加えると、多くの場合、使い勝手や安全性は向上します。
> 「参照」は、ポインタの機能のうち、「オブジェクトの参照」しかサポートしませんが、逆にいえば、用途が明確であり、誤って他の目的に流用されたりする心配もありません。
