# 循環参照とWeak\<T\>

絶対に片付けられることのないメモリ(**メモリリーク**)を、Rustではメモリ安全保障により生成してしまいにくいが、生成することが不可能にはならない。
Rustでは、`Rc<T>`と`RefCell<T>`を使用してメモリリークを許可すると、**循環参照**によるメモリリークが起きる可能性がある。要素がお互いを参照すると、循環の各要素の参照カウントが絶対に0にならないので、値が絶対にドロップされなくなってしまう。

`Rc<T>`値を含む`RefCell<T>`値があるなど、内部可変性と参照カウントのある型がネストして組み合わさっていたら、 循環していないことをプログラマが保証しなければならない。
循環参照を回避する別の解決策は、ある参照は所有権を表現して他の参照はしないというように、**データ構造を再構成**すること。 
結果として、所有権のある関係と所有権のない関係からなる循環ができ、所有権のある関係だけが、値がドロップされうるかどうかに影響する。



## 循環参照を回避する: Rc\<T\>をWeak\<T\>に変換する

`Rc::clone`を呼び出すと、`Rc<T>`インスタンスの`strong_count`(**強い参照**)が増える。一方、`Rc::downgrade`メソッドに`Rc<T>`への参照を渡すことで、`Rc<T>`内部の値への**弱い参照**を作ることもできる。

`Rc::downgrade`を呼び出すと、型`Weak<T>`のスマートポインタが得られる。 `Rc::clone`を呼び出して`strong_count`を1増やす代わりに、`Rc::downgrade`を呼び出すと、`weak_count`が1増える。 `strong_count`同様、`Rc<T>`型は`weak_count`を使用して、幾つの`Weak<T>`参照が存在しているかを追跡する。

強い参照は、`Rc<T>`インスタンスの所有権を共有する。弱い参照は、所有権関係を表現しない。強い参照カウントが0になると、弱い参照は全て無効になる。`weak_count`の数に関わらず、`Rc<T>`は片付けられる。

弱い参照は、参照を得るために**一時的に強い参照にする**。弱い参照を一時的に強い参照にして`Rc<T>`を得るには、`Weak<T>`の`upgrade`メソッドを呼び出す。このメソッドは`Option<Rc<T>>`を返す(Optionなのは、強い参照がもう存在しない、つまり無効なポインタかもしれないから)。

**結論**：通常の参照(強い参照)は所有権を共有し、参照することができるが、場合によっては循環参照になってしまうことがある。弱い参照を併用することで、これを解決できる。`Rc::downgrade`で`Weak<T>`を得て循環参照を回避しつつ、必要なら`Weak::upgrade`で参照先の`Rc<T>`を得ることができる。