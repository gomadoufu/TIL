# クロージャ

変数に保存したり、引数として他の関数に渡すことのできる匿名関数

**関数と異なり、**クロージャは呼び出された環境のスコープの値をキャプチャすることができる。

```rust
let closure_name = | capture | {
  println!("キャプチャした変数capture:{}", capture);
  capture
};

closure_name(variable); //呼び出し
```

### 関数の引数や戻り値型注釈が必須なのに、クロージャにそれがないのはなぜ？

クロージャの引数は、ユーザーに露出するインターフェイスになり得ないから。関数の仮引数や戻り値は、明示的なインターフェイスの一部(シグニチャだけ見るユーザーを思い浮かべよう)なので、堅実に定義する必要がある。
しかし、クロージャは公開されず、ふつう本体が短く、さらに狭い文脈の中で使われる。このような使用のされ方では、堅実な定義の必要はなく、しかもコンパイラが自信を持ってそれらの型を推論できる。

型注釈ができないわけではない。必要なら注釈することができる。また、クロージャの本体がただ１つの式からなる時、大括弧を省略できる

```rust
fn add_one_v1(x: u32) -> u32 {
  x + 1
} //普通の関数
let add_one_v2 = | x | { x + 1 }; //クロージャにしたもの
let add_one_v3 = | x: u32 | -> u32 { x + 1 }; //型注釈を加えたもの
let add_one_v4 = | x | x + 1 ; //１つの式なので大括弧を省略したもの
```

コンパイラは、クロージャが初めて呼び出された時点でその引数と戻り値の型を決める。つまり、次のようなコードは不可

```rust
let example = |x| x;

let string = example(String::from("hello"));
//この時点で、exampleはStringを受け取りStringを返すクロージャだと決定される
let int = example(5); //コンパイルエラー！！
```

### ジェネリック引数とFnトレイトを使用して、クロージャの結果を保存する

クロージャの結果をキャッシュする構造体を作成することで、同じコード呼び出しの繰り返しを避ける。このパターンは**メモ化** *memoization*または**遅延評価** *lazy evaluation*として知られている。







