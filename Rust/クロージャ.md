# クロージャ

変数に保存したり、引数として他の関数に渡すことのできる匿名関数

**関数と異なり、**クロージャは呼び出された環境のスコープの値をキャプチャすることができる。

### 関数の引数や戻り値型注釈が必須なのに、クロージャにそれがないのはなぜ？

クロージャの引数は、ユーザーに露出するインターフェイスになり得ないから。関数の仮引数や戻り値は、明示的なインターフェイスの一部(シグニチャだけ見るユーザーを思い浮かべよう)なので、堅実に定義する必要がある。
しかし、クロージャは公開されず、ふつう本体が短く、さらに狭い文脈の中で使われる。このような使用のされ方では、堅実な定義の必要はなく、しかもコンパイラが自信を持ってそれらの型を推論できる。

型注釈ができないわけではない。必要なら注釈することができる。また、クロージャの本体がただ１つの式からなる時、大括弧を省略できる

```rust
fn add_one_v1(x: u32) -> u32 {
  x + 1
} //普通の関数
let add_one_v2 = | x | { x + 1 }; //クロージャにしたもの
let add_one_v3 = | x: u32 | -> u32 { x + 1 }; //型注釈を加えたもの
let add_one_v4 = | x | x + 1 ; //１つの式なので大括弧を省略したもの
```

コンパイラは、クロージャが初めて呼び出された時点でその引数と戻り値の型を決める。つまり、次のようなコードは不可

```rust
let example = |x| x;

let string = example(String::from("hello"));
//この時点で、exampleはStringを受け取りStringを返すクロージャだと決定される
let int = example(5); //コンパイルエラー！！
```



### クロージャの型とトレイト

クロージャの型は、特別なトレイトを使って表される。すべてのクロージャは、以下のいずれかのトレイトを実装している。

- `Fn`トレイト
- `FnMut`トレイト
- `FnOnce`トレイト

例えば、`u32`型の引数をひとつ取り、`u32`を返すクロージャの型は

```rust
Fn(u32) -> u32
```

となる。

トレイト境界としてクロージャを指定する例を示す。

```rust
struct Cacher<T>
    where T: Fn(u32) -> u32
{
    calculation: T,
    value: Option<u32>,
}
```



### 環境のキャプチャについて

関数になくてクロージャにある特徴は、環境をキャプチャし、**自分が定義されたスコープの変数にアクセスできる**こと。

```rust
fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
```

ここで、`x`は`equal_to_x`の引数でもないのに、 `equal_to_x`が定義されているのと同じスコープで定義されている`x`変数を`equal_to_x`クロージャは使用できている。関数では同じことはできない。

クロージャのトレイト3種は、環境のキャプチャ方法3種(ムーブ、不変借用、可変借用)と対応している。

- `FnOnce`は、クロージャの環境から、**キャプチャした変数を消費する**。 キャプチャした変数を消費するために、定義された際このタイプのクロージャは変数の所有権を奪い、 自身にムーブする。
- `FnMut`は、可変で値を借用し、環境を変更することができる。
- `Fn`は、環境から値を不変で借用する。

クロージャを生成する時、クロージャが環境を使用する方法に基づいて、コンパイラはどのトレイトを使用するか推論する。
 少なくとも1回は呼び出されるので、全てのクロージャは`FnOnce`を実装している。
キャプチャした変数をムーブしないクロージャは、 `FnMut`も実装し、キャプチャした変数に可変でアクセスする必要のないクロージャは、`Fn`も実装している。

**環境でクロージャが使用している値の所有権を奪うことをクロージャに強制したい**なら、引数リストの前に`move`キーワードを使用できます。 このテクニックは、新しいスレッドにデータが所有されるように、クロージャを新しいスレッドに渡して、 データをムーブする際などに有用。マルチスレッドの文脈でよく出てくる。

```rust
fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!("xは既にムーブされた: {:?}", x); //基本型は通常ムーブされないが、moveキーワードでムーブした

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
```


















