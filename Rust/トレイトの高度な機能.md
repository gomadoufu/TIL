# トレイトの高度な機能



 ## 関連型でトレイト定義におけるプレースホルダーの型を指定する

トレイトのメソッド定義がシグニチャで`<T>`などのプレースホルダーの型を使用できるように、**関連型**でトレイトとプレースホルダーを結びつけるようになっている。実際にトレイトを実装するときに、関連型に具体的な型を指定する。

例えば`Iterator`トレイトでは、型`Item`がプレースホルダー型で、`next`メソッドがこれをシグネチャで使用している。`Iterator`トレイトを実装するものは、`Item`の具体的な型を指定し、`next`メソッドは、 その具体的な型の値を含む`Option`を返すという流れ。

```rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;
}
```



## デフォルトのジェネリック型引数と、演算子オーバーロード

ジェネリックな型引数を使用する際、`<プレースホルダーの型=具体的な型>`と書くことで、既定の具体的な型を指定できる。これにより、 既定の型が動くのなら、トレイトを実装する側が具体的な型の指定を省略できる。

このテクニックを利用すると、**演算子オーバーロード**が可能になる。

Rustでは通常、独自の演算子を作ったり、任意の演算子をオーバーロードすることはできない。しかし、 演算子に紐づいたトレイトを独自に実装することで、`std::ops`にある処理と対応するトレイトをオーバーロードでき、これにより擬似的に演算子オーバーロードが実現できる。 次の例では、`Point`構造体に`Add`トレイトを実装することでこれを行なっている

```rust
#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}
```

ちなみに、`Add`トレイトの実装は、以下のようになっている。

```rust
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}
```

トレイトのシグニチャに、見慣れない`RHS=Self`という箇所がある。
この記法は、**デフォルト型引数**と呼ばれる。 RHSというジェネリックな型引数("right hand side": 右辺の省略形)が、`add`メソッドの`rhs`引数の型を定義している。 `Add`トレイトを実装する際に`RHS`の具体的な型を指定しなければ、`RHS`の型は標準で`Add`を実装している型そのものである`Self`になる。



## 同じ名前のメソッド呼び出しを明確化にするフルパス記法

同名の関連関数・メソッドが定義されているとき、構造体(型)とトレイトの状況によって、解決方法が異なってくる。

- 構造体とトレイトで**同名のメソッド**が定義されている場合
  → デフォルトで構造体のメソッドが使われる
  → トレイトのメソッドを呼びたい場合、`Trait::method(&instanceofstruct)`のように明示的に呼ぶ必要がある。この場合の`::`は関連関数を意味するのではなく、単に明示するためのものであることに注意(メソッドなので`method`は引数に`&self`をとる)。
- 構造体とトレイトで**同名の関連関数**が定義されている場合
  → メソッドであれば、引数にとる構造体インスタンスの参照で、弁別可能
  → 関連関数は引数を持たないので、呼び出された際にどの実装を使えばいいのか決定できないので、上記の解決方法は使えない
  →**フルパス記法を使う** `<Struct as Trait>::function()`  Structに実装されたTrait由来の関連関数を呼び出せる



## ニュータイプパターンを使用して、外部の型に外部のトレイトを実装する

Rustにある孤児のルール(**オーファンルール**)により、自分のクレートに無い外部の型に対して、同じく外部の型を実装することは禁止されている。しかし、デザインパターンである**ニュータイプパターン**を使用して、これを回避できる。

ニュータイプパターンはシンプルで、ラッパーとなるタプル構造体を用意し、外部の型を包む(内部の型として扱ってしまう！)だけである。これを使って、外部の型`Vec<T>`に、外部のトレイト`Display`を実装してみる。

```rust
struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

ただし、ラッパーとなったタプル構造体には本来`Vec<T>`にあるはずのメソッドがないので、別でラッパーに`Deref`を実装して`Vec<T>`をその都度取り出すか、メソッドを自力で実装することになる。

