# トレイトオブジェクトで、異なる型の値を許容する

トレイトオブジェクトとは、指定したトレイトを実装する、何らかの型のインスタンスのことである。`&`参照や`Box<T>`スマートポインタなどの、 **何らかのポインタ**を指定し、それから関係のあるトレイトを指定することで作成できる。

どこでトレイトオブジェクトを使用しようと、 Rustの型システムはコンパイル時に、その場所で使用されているあらゆる値が、そのトレイトオブジェクトのトレイトを実装していることを保証する。

次の例は、トレイトオブジェクトを示す`dyn`キーワードとともに、トレイトオブジェクト`Box<Draw>`を使用している。`Box<Draw>`は、`Draw`トレイトを実装する`Box`内部の任意の型の代役となる。

```rust
pub struct Screen {
    pub components: Vec<Box<dyn Draw>>, //Drawを実装した型なら何でもいいよ〜
}
```

`Screen`構造体に、`components`の各要素に対して`draw`メソッドを呼び出す`run`というメソッドを定義してみる。(描画GUIアプリケーションを想定)

```rust
impl Screen {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

この書き方は、トレイト境界&ジェネリクスの構造体と似ているが、**明確に異なる**。ジェネリックな型引数は、一度に1つの具体型にしか置き換えられない(単相化)のに対して、トレイトオブジェクトは、 **実行時に**(*dynamic*に)トレイトオブジェクトに対して複数の具体型で埋めることができる。

例として、ジェネリックな型引数とトレイト境界を併用したパターンを次に示す。

```rust
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

こうすると、`Screen`インスタンスの`Vec<T>`の要素は、全て`Button`だったり、`TextField`だったり、単一の要素に制限されてしまう(単相化されるため)。 絶対に同種のコレクションしか持つ予定がないのなら、ジェネリクスとトレイト境界は、 定義がコンパイル時に具体的な型が使用されるので、パフォーマンス的に望ましい。
一方で、メソッドがトレイトオブジェクトを使用すると、1つの`Screen`インスタンスが、 `Box<Button>`と`Box<TextField>`を含む`Vec<T>`を保持できるようになる。

単に、複数の型からなるベクタを作りたいなら、`enum`を定義して、そのベクタを作れば解決できる。しかし、この方法は**コンパイル時に必要な型が全てわかっている**ときにのみ使える。
自分の作ったツール、例えば上記の描画アプリケーションを考えてみよう。ユーザが自由にコンポーネントを追加できるようにするためには、ツールを完成させて配布した後からでも、ベクタにコンポーネントを追加できるような仕組みにしておく必要がある。
トレイトオブジェクトを使うことで、追加のコンポーネントに必要なAPIを定め、そのAPIを実装したすべての型を許容して(**ダックタイピング**)、柔軟な仕組みを実現できる。



### トレイトオブジェクトは、ダイナミックディスパッチを行う

ジェネリクスを使用した場合コンパイラは、関数やメソッドの具体的な実装を、ジェネリックな型引数の箇所に使用している具体的な型に対して生成する(単相化)。単相化の結果吐かれるコードは、**スタティックディスパッチ**される。これは、コンパイル時に、コンパイラはどのメソッドを呼び出しているかわかっている決定のことである。
**ダイナミックディスパッチ**はそれとは対照的に、コンパイル時コンパイラは、どのメソッドを呼び出しているのかわかっていない。 ダイナミックディスパッチの場合、コンパイラは、どのメソッドを呼び出すか実行時に決定し、コードを生成する。

トレイトオブジェクトを使用すると、コンパイラはダイナミックディスパッチを使用しなければならない。 コンパイラは、トレイトオブジェクトを使用しているコードで使用される可能性のある型全てを把握していないため、 どの型に実装されたどのメソッドを呼び出すかわからない。代わりに実行時に、トレイトオブジェクト内でポインタを使用して、どのメソッドを呼ぶか検索して決定している。
スタティックディスパッチでは行われないこの検索が起きる時には、 実行時コストがかかる。また、ダイナミックディスパッチは、コンパイラがメソッドのコードをインライン化することも妨げ、結果ある種の最適化が不可能にもなる。
