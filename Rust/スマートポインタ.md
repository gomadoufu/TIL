# スマートポインタ

**ポインタ**は、メモリのアドレスを含む変数の一般的な概念。
Rustにおいて、最もありふれたポインタは参照。

一方、**スマートポインタ**は、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造のこと。もともとはC++にあったもの。
Rustでは、標準ライブラリに定義された色々なスマートポインタが、 参照以上の機能を提供する。
ちなみに`String`や`Vec<T>`は、スマートポインタという呼び方こそされないが、ヒープへの参照を持ち、さらにキャパシティや保証など追加の能力をもつので、これらはスマートポインタの一種である。

また、所有権と借用の概念を使うRustにおける両者の違いとして、参照はデータを借用するだけのポインタなの対し、**スマートポインタはデータを所有する**という違いがある。例えば`String`はデータを所有する(コピーでなくムーブされる)。

スマートポインタは、参照の振る舞いを規定する`Deref`トレイトと、スコープを外れた時のデストラクタを規定する`Drop`トレイトの両方を実装した、構造体として実装される。
主なスマートポインタは5つある

- ヒープに値を確保する`Box<T>`
- 複数の所有権を可能にする、参照カウント型の`Rc<T>`
- 内部可変な`RefCell<T>`と、借用規則を実行時に強制する`Ref<T>`や`RefMut<T>`



## ヒープのデータを指す`Box<T>`

最もシンプルなスマートポインタは**ボックス**であり、その型は`Box<T>`と表記される。
ボックスは、スタックではなくヒープにデータを格納し、スタックに固定サイズのポインタを積む。

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

ボックスは、データをスタックの代わりにヒープに格納する以外は、特別な能力は何もない。以下のような場面でよく使われる

- コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時(後述)
- 多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時(ポインタのみをコピーしてパフォーマンスを向上させる)
- 値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時(つまりトレイトオブジェクトを使う場合)

### ボックスで再起的な型定義を可能にする

コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時、ボックスを使うことができる。

例えば、Haskellにあるようなコンスリストなどの**再帰的な型**は、コンパイル時にサイズがわからない型である。再帰的な型の値は、値の一部として同じ型の他の値を持つ。値のこうしたネストは、理論的には無限に続く可能性があるので、コンパイラは再帰的な型の値が必要とする領域を知ることができずコンパイルできない。 しかし、ボックスのサイズはわかっているので、再帰的な型の定義にボックスを挟むことで再帰的な型を作ることができる。

```rust
//Box<T>で再帰的な型(コンスリスト)を実装
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```



## 参照カウント方式の`Rc<T>`

単独の値が、複数の所有者を持つ可能性がある。
例えばグラフでは、複数の辺が同じノードを指す場合がある。メモリのように考えれば、概念的にそのノードはそれを指す全ての辺に所有されており、指す辺がなくならない限り、ノードは片付けられるべきではない。

複数の所有権を可能にするため、Rustには`Rc<T>`という型がある。Rcは*reference counting*の省略形。この型により、読み取り専用だが、プログラムの複数箇所間でデータを共有することができるようになる。

`Rc<T>`型は、値がまだ使用中かどうか決定するために、値への参照の数を追跡する。値への参照が一つもなければ、どの参照も無効にすることなく(ダングリングポインタを生み出すことなく)、値を片づけられる。

`Rc<T>`は、ヒープにプログラムの複数箇所で読む何らかのデータを確保したいけれど、 コンパイル時にはどの部分が最後にデータを使用し終わるか決定できない時に使われる。

**`Rc<T>`は、シングルスレッドの文脈でしか使用できないことに注意**

`Rc<T>`を使ってコンスリストを実装してみる

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a));
}
```

ここで、`Rc::clone(&a)`は`a.clone()`と大きく異なることに注意。多くの型の`clone()`実装はデータのディープコピーで時間がかかるが、`Rc::clone()`は参照カウントをインクリメントしているだけで時間はかからない。

`Rc<T>`の参照カウントの数は、`Rc::strong_count`関数で得られる。`Rc::clone()`が参照カウントを増やし、`Rc<T>`の値がスコープを抜ける時に`Drop`トレイトの実装が参照カウントを減らす。



## 内部可変性と `RefCell<T>`

内部可変性パターンは、そのデータへの不変参照がある時でさえもデータを可変化できるRustでのデザインパターンである。普通この操作は借用規則により許可されないが、データ構造内で`unsafe`なコードを使用して、それを可能にしている。

参照と`Box<T>`では、借用規則をコンパイル時に強制している。それに対し`RefCell<T>`では、借用規則を**実行時に**強制する。そのため、参照で借用規則を破ってもコンパイルエラーになるだけだが、`RefCell<T>`で借用規則を破るとプログラムはパニックして終了する。

借用規則を実行時に代わりに精査する利点は、コンパイル時の精査では許容されない特定のメモリ安全な操作が許容されることにある。コードが借用規則に従っているとプログラマは確証を得ているが、コンパイラがそれを理解し保証することができない時に、 `RefCell<T>`型は有用。

**`RefCell<T>`は、シングルスレッドの文脈でしか使用できないことに注意**



### 内部可変性: 不変値への可変借用

公開されているAPIの都合などにより、不変な参照しか取れないが、それでも値を変更したい時に、内部可変性パターンを使うことになる。
不変参照をとる値をあらかじめ`RefCell::new()`で包んでおき、必要な時に`borrow_mut()`メソッドを用いることで、中の値への可変な参照を得ることができる。

`RefCell<T>`は、可変な参照だけでなく、実行時の不変な参照を作ることもできる。不変および可変な参照を作成するとき、通常はそれぞれ`&`と`&mut`を使用するが、これに対応して`RefCell<T>`では`borrow`と`borrow_mut`メソッドを使用する。
`borrow`メソッドは、スマートポインタ型の`Ref<T>`を返し、`borrow_mut`はスマートポインタ型の`RefMut<T>`を返す。 どちらの型も`Deref`を実装しているので、普通の参照のように扱うことができる。

`RefCell<T>`は、現在活動中の`Ref<T>`と`RefMut<T>`スマートポインタの数を追いかけて、コンパイル時の借用規則と全く同じように、複数の不変借用または1つの可変借用を持たせてくれる。



### `Rc<T>`と`RefCell<T>`を組み合わせて、可変なデータに複数の所有者を持たせる

`RefCell<T>`の一般的な使用法は、`Rc<T>`と組み合わせることにある。`RefCell<T>`をラップした`Rc<T>`を用意すれば、複数の所有者を持ち、さらに、可変化できる値を得ることができる。

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>), //RcでRefCellを包む
    Nil,
}

use List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    //Listは全て不変を保てている
    //valueとaはRcで所有権を共有
    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
    //Rcなのでbからでもcからでもaを参照できる
    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

  　//RefCellの力でvalueを変更
    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}

//全て15に書き変わる
// a after = Cons(RefCell { value: 15 }, Nil)
// b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
// c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
```



## スマートポインタまとめ(シングルスレッド)

- `Rc<T>`は、同じデータに複数の所有者を持たせてくれる; `Box<T>`と`RefCell<T>`は単独の所有者。
- `Box<T>`では、不変借用も可変借用もコンパイル時に精査できる; `Rc<T>`では不変借用のみがコンパイル時に精査できる; `RefCell<T>`では、不変借用も可変借用も実行時に精査される。
- `RefCell<T>`は実行時に精査される可変借用を許可するので、`RefCell<T>`が不変でも、 `RefCell<T>`内の値を可変化できる。
