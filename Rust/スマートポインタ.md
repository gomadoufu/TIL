# スマートポインタ

**ポインタ**は、メモリのアドレスを含む変数の一般的な概念。
Rustにおいて、最もありふれたポインタは参照。

一方、**スマートポインタ**は、ポインタのように振る舞うだけでなく、追加のメタデータと能力があるデータ構造のこと。もともとはC++にあったもの。
Rustでは、標準ライブラリに定義された色々なスマートポインタが、 参照以上の機能を提供する。
ちなみに`String`や`Vec<T>`は、スマートポインタという呼び方こそされないが、ヒープへの参照を持ち、さらにキャパシティや保証など追加の能力をもつので、これらはスマートポインタの一種である。

また、所有権と借用の概念を使うRustにおける両者の違いとして、参照はデータを借用するだけのポインタなの対し、**スマートポインタはデータを所有する**という違いがある。例えば`String`はデータを所有する(コピーでなくムーブされる)。

スマートポインタは、参照の振る舞いを規定する`Deref`トレイトと、スコープを外れた時のデストラクタを規定する`Drop`トレイトの両方を実装した、構造体として実装される。
主なスマートポインタは5つある

- ヒープに値を確保する`Box<T>`
- 複数の所有権を可能にする、参照カウント型の`Rc<T>`
- `RefCell<T>`
- 実行時に借用規則を強制する`Ref<T>`と`RefMut<T>`



## ヒープのデータを指すBox\<T\>

最もシンプルなスマートポインタは**ボックス**であり、その型は`Box<T>`と表記される。
ボックスは、スタックではなくヒープにデータを格納し、スタックに固定サイズのポインタを積む。

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

ボックスは、データをスタックの代わりにヒープに格納する以外は、特別な能力は何もない。以下のような場面でよく使われる

- コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時(後述)
- 多くのデータがあり、その所有権を移したいが、その際にデータがコピーされないようにしたい時(ポインタのみをコピーしてパフォーマンスを向上させる)
- 値を所有する必要があり、特定の型であることではなく、特定のトレイトを実装する型であることのみ気にかけている時(つまりトレイトオブジェクトを使う場合)

### ボックスで再起的な型定義を可能にする

コンパイル時にはサイズを知ることができない型があり、正確なサイズを要求する文脈でその型の値を使用する時、ボックスを使うことができる。

例えば、Haskellにあるようなコンスリストなどの**再帰的な型**は、コンパイル時にサイズがわからない型である。再帰的な型の値は、値の一部として同じ型の他の値を持つ。値のこうしたネストは、理論的には無限に続く可能性があるので、コンパイラは再帰的な型の値が必要とする領域を知ることができずコンパイルできない。 しかし、ボックスのサイズはわかっているので、再帰的な型の定義にボックスを挟むことで再帰的な型を作ることができる。

```rust
//Box<T>で再帰的な型(コンスリスト)を実装
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

