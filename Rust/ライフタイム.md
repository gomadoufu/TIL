# ライフタイム

Rustにおいて、全ての参照はライフタイムを保持する。
ライフタイムとは、その参照が有効になるスコープのこと。

多くの場合、型が推論されるように、ライフタイムも暗黙的に推論される。
一方、複数の型の可能性があるときに型を注釈しなければならないのと同様に、参照のライフタイムが複数の方法で関係することがある場合には、ライフタイムを注釈しなければならない。

### 借用チェッカー *borrow checker*

Rustコンパイラには、スコープを比較して全ての借用が有効であるかを決定する**借用チェッカー**がある。
借用チェッカーはスコープ同士の2つのライフタイム `'a` , `'b` のサイズを比較し、変数`r`は`'a`のライフタイムだけれども、`'b`のライフタイムのメモリを参照していることを確認する。そして、`'b'`は`'a`よりも短いので、参照の対象が参照ほど長生きしないこのプログラムは拒否される。

```rust
{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```



### ライフタイム注釈記法

ライフタイム注釈は、ライフタイムをコンパイラに明示するだけであり、いかなる参照の生存期間も変えることはない。ライフタイム注釈は、ライフタイムに影響することなく、複数の参照のライフタイムのお互いの関係を記述する。

ライフタイム注釈は、アポストロフィーで始まり、通常全部小文字。関数の引数に注釈するときは、実引数変数は通常参照なので、参照の`&`の後に配置し、注釈と参照の方を区別するために空白を1つ使用する。

```rust
&i32        // ただの参照
&'a i32     // 明示的なライフタイム付きの参照
&'a mut i32 // 明示的なライフタイム付きの可変参照
```

関数シグニチャにおけるライフタイム注釈の例:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
} //「この関数から返る文字列スライスは、少なくとも引数のライフタイム'aと同じだけ生きるとプログラマは思ってるよ」
```

このように、関数にライフタイムを注釈するときは、注釈は関数の本体ではなくシグニチャに付与する。
コンパイラは、注釈がなくとも関数内のコードを解析できるが、関数に関数外からの参照や関数外への参照がある場合、引数や戻り値のライフタイムを推論することは不可能になる。 この場合ライフタイムは、関数が呼び出される度に異なる可能性があるため。こう言ったときに、手動でライフタイムを注釈する必要が出てくる。

究極的にライフタイム記法は、関数のいろんな引数と戻り値の**ライフタイムを接続すること**に関するもの。 一旦それらが繋がれば、コンパイラはメモリ安全な処理を許可し、ダングリングポインタを生成したりメモリ安全性を侵害したりする処理を、禁止することが出来る。

関数やメソッドの引数のライフタイムは、*入力ライフタイム*と呼ばれ、 戻り値のライフタイムは*出力ライフタイム*と呼ばれる。



### 構造体やメソッド定義におけるライフタイム注釈

構造体やメソッド定義にライフタイムを注釈する際、ジェネリックな型引数と同じ記法を使用する。

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}
```



### 静的ライフタイム

静的ライフタイム`'static`という特殊なライフタイムがある。これは、この参照がプログラムの**全期間生存できる**ことを意味する。
文字列リテラルは全て`'static`ライフタイムになる。

```rust
// 僕は静的ライフタイムを持ってるよ
let s: &'static str = "I have a static lifetime.";
```

文字列のテキストは、プログラムのバイナリに直接格納され、常に利用できる。そのため、全文字列リテラルのライフタイムは静的ライフタイムである。

