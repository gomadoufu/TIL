# 高効率言語 Rust メモ

## Chapter 3

#### Section01

- 所有権システムとは、確保したメモリを、仕様が終わった時点で自動的に破棄する機能のこと。
-  Rustでは、波括弧を利用して任意の場所にブロックを宣言できる。
- 所有権の移動をmoveという
- 所有権の移動を監視し、メモリの有効性を検証するコンパイラの機能をborrow checkerという

### 所有権の原則

1. 値には所有権があり、変数は値の所有者になれる。
2. 所有権は移動するが、所有者は一人(一つの変数)だけである。
3. 所有者が有効スコープから出ると、値は破棄される。



- Rustのあらゆる値が所有権システムの対象となるわけではなく、プリミティブ型は例外。
  プリミティブ型はスタック領域に割り当てられるため、固定サイズかつコピーが早いので所有権の管理はされない(ムーブではなく全てコピーで処理される)
- 所有権が移動する型(オブジェクト、文字列や構造体)であっても、複製(clone)を行うことで、所有権の移動を回避できる

#### Section02

- 所有権はムーブの他に、関数呼び出しでも移動する。
- 値をreturnすることで、所有権を関数の呼び出し元に返すことができる
- ただ、ちょっと関数を呼び出しただけで値の所有権が移動するのでは不便な時もある。
  そういう時のために、Rustでは**借用**という仕組みがある
- 借用とは、実際的には、関数の引数に**参照型**`&`を指定すること
- 参照を受け渡すことで、関数呼び出し元では関数呼び出し後も値を利用できる
- 関数の中で値を変更したいときは、**可変参照 &mut**を用いると良い
- 参照はずし(デリファレンス)はC++と同じく\*変数名と書く

#### Section03

- 複合型として、タプルと配列がある
- タプルの要素は幾つでもいい。要素は タプル名.0 タプル名.1のような形でアクセスできる
- 頻繁に利用するタプルがあれば、構造体として定義して型のように扱うといいかも
  `struct Item(String i64)`
- Rustの配列は、**すべての要素が単一の型でなければならない**。
- スライスとは、**固定長データ型(配列・ベクター・文字列など)の一部分を参照する、可変長データ型**のこと
- スライスは参照なので所有権の問題はない
- スライスは`&変数名 [n..m]`のように書く

#### Section04

- 構造体の書式
  ``` Rust
  struct 構造体名 {
    フィールド名: 型,
    フィールド名: 型, //最終フィールドであっても、末尾のカンマを記述して良い
  }
  ```
  
- 構造体はクラスを作る気持ちで使えそう。
  オブジェクトを生成するときは、
  
  ```Rust
  let 変数名 = 構造体名 {
    フィールド名: 値
  }
  ```
  
  と書く。
  
#### Section05

- Rustで文字列を利用する場合、"String"型か"&str"型をつかう

- プログラム内にダブルクォートで(リテラルとして)文字列を記述したとき、その型は&strとなる

- **String型はベクターオブジェクト**である。StringはVec\<u8\>型の別名であり、1バイト単位で拡張できる可変長データ。

- **&str型はスライス**である。&strはスライス&[u8]型の別名であり、参照型なので所有権を持たない。

- 文字列から1文字取り出すには、`.chars()`メソッドを使うとよい

- &strに対してスライスを使ったり、`.bytes()`メソッドを使うことで、バイト単位で文字列を切り出せる(日本語などのマルチバイト文字の場合、1バイトと1文字が対応していないので注意)

- &strとStringは相互変換できる
  ```rust
  let string: &str = "&str";
  //&strからStringへの変換
  let String1: String = String::from(string);
  let String2: String = string.to_string();
  //Stringから&strへの変換
  let string1: &str = &String1;
  let string1: &str = String1.as_str();
  ```
  
- &strの`len()`メソッドは、文字数ではなくバイト数を返すので注意

- ライフタイムを明示すると、Rustの文字列リテラルは`&'static str`となる。'staticは、プログラムの最初から最後までを表すライフタイム。

#### Section06

- &strのbytesメソッドやcharsメソッドはイテレータを返すので、`enumerate()`メソッドでインデックスを得てfor分で回したり、`.take()`メソッドで先頭から指定個数のデータを取り出したりできる。
- 文字列処理には、findメソッドやreplaceメソッド、splitメソッドなど便利なメソッドがたくさん用意されている

#### Section07

- Rustでグローバル変数をどうしても扱いたい時には、扱う箇所をunsafeブロックで囲む必要がある

## Chapter 4

#### Section01

- 構造体にメソッドを定義する
  ```rust
  struct 構造体の名前 {
    フィールド定義
  }
  
  impl 構造体の名前 {
    fn メソッド名（&self, 引数...){
      メソッド定義  
    }
  }
  ```

  メソッドは、**構造体名.メソッド名()**で呼び出せる。
  
- implブロック内で定義する関数(メソッド)でありながら、構造体自身(self)を引数に取らないものを、**関連関数**と呼ぶ。Javaのstaticメソッドに近いもの。関連関数は**構造体名::関数名()**で呼び出せる。
  ```rust
  //関連関数として、Person構造体のオブジェクトを新しく生成する、newメソッドを実装した例
  impl Person {
    fn new (name: String, address: Address, age: i32) -> Self {
      Person{name, address, age}
    }
  }
  
  let person = Person::new(); //オブジェクト生成
  ```
  
#### Section02

- トレイトとは、特性・特色・特徴という意味の単語
  
- trait */treit/* noun[countable]
    (formal) particular quality in someone's character
    ”Japanese traits" "日本の国民性"
  
- Rustでのトレイトは、Haskellの型クラスのようなもので、構造体の性質・ふるまいを抽象化したもの。型インターフェイスと捉えることもできそう
  ```rust
    //トレイトの定義
    trait トレイト名 {
      fn メソッド名(&self, 引数...) -> 戻り値の型; //抽象メソッドのように書く
    }
    //トレイトの実装 implブロックとforキーワードを使う
    impl トレイト名 for 構造体名 {
      fn メソッド名(&self, 引数...) -> 戻り値の型 {
        //メソッドの実際の処理
      }
    }
  ```
  
- Rustでは未使用の変数があると警告が出るが、変数名をアンダースコアから始めると未使用でも警告しなくなる
- トレイトにデフォルトメソッド(Javaの抽象クラスにおける具象メソッド、インターフェイスだけでなく実際の定義のあるもの)を定義することで、そのトレイトを実装する構造体に自動的にメソッドを実装することができる。あるトレイトを実装している構造体全てに、共通のメソッドを持たせたい時に役立ちそう
  
#### Section03

- ジェネリクスは、抽象的な形を指定して、さまざまなデータ型の操作を可能にするプログラミング手法のこと
  ```rust
  fn 関数名 <T: トレイト> (引数1: T, 引数2: T, ...) -> 戻り値の型 {
    //メソッドの実装
  }
  ```
  
  
  
  ```rust
    //add関数を作ってみる
    fn add_i32(x: i32, y: i32) -> i32 {
      x + y
    }
    //ジェネリクスを利用して抽象化
    fn add <T: std::ops::Add<Output=T>> (x:T, y:T) -> T{
      x + y
    }
  ```
  
- ジェネリクスで受け付けるさまざまな型(構造体)に対して、「指定のトレイトを実装するべきである」という制約を課すとき、これを**トレイト境界**という。
  例えば、上のadd関数ではトレイト境界std::ops::Addにより、型変数Tには足し算を実装した型しか入れられないようになっている。
  
- 複数のトレイと境界を指定することもできる。コピートレイトも必要だった場合、`fn add <T: std::ops::Add<Output=T> + Copy>`のように「+」を利用して書ける。

- トレイト境界が長くなってしまう場合、whereキーワードを使って見やすく記述することもできる。
  ```rust
  fn 関数名 <T> (引数:T ...) -> 戻り値の型
    where T: トレイト {
      //メソッドの実装
  }
  ```

  こっちの書き方の方が良さそう。

- 関数だけでなく、構造体の宣言でもジェネリクスを指定できる
  ```rust
  struct 構造体<T> {
    x: T,
    y: T,
  }
  ```
  
  さらに、構造体のメソッドもジェネリクスで定義できる。トレイト境界も持たせられる
  ```rust
  impl <T> 構造体<T> where T: トレイト {
    fn メソッド名(引数: T) -> 戻り値の型 {
      //メソッドの実装
    }
  }
  ```
  
#### Section04

- イテレータを返すメソッドには、所有権の移動するものとしないものがあるので、よく選ばないといけない
- イテレータを使うには、標準ライブラリのIteratorというトレイトを実装することになっている
- イテレータを自分で作るには、構造体にIteratorトレイトで求められるItem型とnextメソッドを実装すればよい
- Iteratorトレイトを実装すると、enumerateメソッドやtakeメソッドに渡せるようになって便利

#### Section05

- Rustで値があるかないかを表現するには、列挙型であるOption型を使う。また、エラーか否かを表現する列挙型のResult型もある

- 列挙型を自分で定義するには、enumキーワードを利用する
  ```rust
  enum 列挙型の名前 {
    値1, 値2, 値3,...
  }
  ```

  列挙型のオブジェクトを生成するには、「型名::値」とする
  ```rust
  let 変数1 = 列挙型::値1;
  let 変数2 = 列挙型::値2;
  ```
  
  構造体と同じように、列挙型にもimplブロックで関連関数やメソッドを定義できる。
  
- パターンマッチングに利用するmatch文は、列挙型だけでなく色々な型に対して使えて便利！！
  アームに記述するパターンにも色々書ける
  
  ```rust
  //変数には、列挙型や構造体のほか、プリミティブ型などを渡せる(もしかしてなんでも渡せる......?)
  match 変数 {
    パターン => 文,
  }
  //たとえば
  match num {
    0 => println!("zero"),
    n if n % 2 == 0 => println!("even"),
    6 | 28 | 496 => println!("perfect"),
    _ => println!("???"),
  }
  ```
  
  
  
  